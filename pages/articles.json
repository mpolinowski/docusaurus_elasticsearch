{
        "title": "NGINX Ingress with Nomad | Mike Polinowski",
        "series": ["PLACEHOLDER"],
        "type": "PLACEHOLDER",
        "description": "DevOpsHashicorpNGINX Ingress with NomadOn this pageNGINX Ingress with NomadNGINX Ingress with NomadPreparationCertbotNomad Job FileNGINX Ingress with Nomad​Running several web applications on a single server usually requires a web proxy to handle to have a single ingress to your server that handles TLS encryption. I already prepared a NGINX Ingress template that can be used to spin up an Ingress inside a Docker container:Github RepositoryLet's migrate this to Nomad.Preparation​Certbot​First I need to create an TLS certificate with certbot:apt install certbotSince NGINX will be running inside a docker container we cannot use the --nginx flag to auto-configure NGINX to use the certificate. Instead we have to use:certbot certonly --standaloneBefore running this command make sure that you have a domain pointing towards your server, e.g. my.server.com and you will have to have opened port 80, e.g. ufw allow 80/tcp to have certbot verify your domain!The command is going to create your certificates in /etc/letsencrypt/live/my.server.com which we will have to provide as a volume to the Nomad process - check out the Hashicorp Nomad Client Configuration for how to configure the client on your server that should run the NGNIX ingress.Nomad Job File​There are two ways on how to provide the NGINX configuration to your Docker container. The first one is to source your configuration in a Git repository and add it to your Nomad job using the Artifact stanza inside the Task directive:artifact { source = git::git@my.gitlab.com:nginx_ingress.git destination = local/nginx options { sshkey = ${base64encode(file(pathexpand( /etc/nomad.d/.ssh/id_rsa )))} depth = 1 } }Create an SSH key /etc/nomad.d/.ssh/id_rsa and add it to your Git repository to allow Nomad to clone it. Now you can mount the local/nginx directory as volumes:config { network_mode = host image = nginx:alpine ports = [ http , https ] volumes = [ local/nginx/configuration/conf.d:/etc/nginx/conf.d , local/nginx/configuration/ssl:/etc/nginx/ssl , local/nginx/configuration/nginx.conf:/etc/nginx/nginx.conf ] }But I don't want to create another repo and just use the Template stanza to generate the entire configuration from my job file:nginx_ingress.nomadjob nginx_ingress { datacenters = [ nginxNTS ] group nginx { count = 1 network { mode = host port http { static = 80 } port https { static = 443 } } service { name = nginx-ingress port = http check { name = HTTP Health path = / type = http protocol = http interval = 10s timeout = 2s } } volume letsencrypt { type = host read_only = true source = letsencrypt } task ingress_container { driver = docker volume_mount { volume = letsencrypt destination = /opt/letsencrypt #in the container read_only = false } config { network_mode = host image = nginx:alpine ports = [ http , https ] volumes = [ local/nginx/nginx.conf:/etc/nginx/nginx.conf , local/nginx/dhparam.pem:/etc/nginx/ssl/dhparam.pem , local/nginx/ssl-params.conf:/etc/nginx/ssl/ssl-params.conf , local/nginx/default.conf:/etc/nginx/conf.d/default.conf , local/nginx/buffers.conf:/etc/nginx/conf.d/buffers.conf , local/nginx/timeouts.conf:/etc/nginx/conf.d/timeouts.conf , local/nginx/header.conf:/etc/nginx/conf.d/header.conf , local/nginx/cache.conf:/etc/nginx/conf.d/cache.conf , local/nginx/gzip.conf:/etc/nginx/conf.d/gzip.conf , local/nginx/index.html:/usr/share/nginx/html/index.html ] } template { data = <<EOHuser nginx;worker_processes auto;worker_rlimit_nofile 15000;pid /var/run/nginx.pid;include /usr/share/nginx/modules/*.conf;events { worker_connections 2048; multi_accept on; use epoll;}http { default_type application/octet-stream; # access_log /var/log/nginx/access.log; # activate the server access log only when needed access_log off; error_log /var/log/nginx/error.log; # don't display server version on error pages server_tokens off; server_names_hash_bucket_size 64; include /etc/nginx/mime.types; sendfile on; tcp_nopush on; tcp_nodelay on; charset utf-8; source_charset utf-8; charset_types text/xml text/plain text/vnd.wap.wml application/javascript application/rss+xml; include /etc/nginx/conf.d/default.conf; include /etc/nginx/conf.d/buffers.conf; include /etc/nginx/conf.d/timeouts.conf; include /etc/nginx/conf.d/cache.conf; include /etc/nginx/conf.d/gzip.conf;} EOH destination = local/nginx/nginx.conf } template { data = <<EOHserver { listen 80; listen [::]:80; server_name my.server.com; return 301 https://$server_name$request_uri;}server { listen 443 ssl http2 default_server; listen [::]:443 ssl; ssl_certificate /opt/letsencrypt/live/my.server.com/fullchain.pem; ssl_certificate_key /opt/letsencrypt/live/my.server.com/privkey.pem; include ssl/ssl-params.conf; include /etc/nginx/conf.d/header.conf; server_name my.server.com; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; }} EOH destination = local/nginx/default.conf } template { data = <<EOH<!DOCTYPE html><html><head> <title>Hello World!</title> <style> html { color-scheme: light dark; } body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style></head><body> <h1>Hello World!</h1></body></html> EOH destination = local/nginx/index.html } template { data = <<EOH-----BEGIN DH PARAMETERS-----MIICCAKCAgEAt59......dfszADFDGV346dfzxg9AC=-----END DH PARAMETERS----- EOH destination = local/nginx/dhparam.pem } template { data = <<EOHssl_protocols TLSv1.3;ssl_prefer_server_ciphers on;ssl_dhparam /etc/nginx/ssl/dhparam.pem;ssl_ciphers ECDH+AESGCM:ECDH+CHACHA20:ECDH+AES256:ECDH+AES128:!aNULL:!SHA1:!AESCCM;ssl_conf_command Options PrioritizeChaCha;ssl_conf_command Ciphersuites TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256;ssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0ssl_session_timeout 10m;ssl_session_cache shared:SSL:10m;ssl_session_tickets off; # Requires nginx >= 1.5.9ssl_stapling on; # Requires nginx >= 1.3.7ssl_stapling_verify on; # Requires nginx => 1.3.7resolver 8.8.8.8 8.8.4.4 valid=300s;resolver_timeout 5s;add_header Strict-Transport-Security max-age=31536000; includeSubDomains always;add_header X-Frame-Options ;add_header X-Content-Type-Options nosniff;add_header X-XSS-Protection 1; mode=block ; EOH destination = local/nginx/ssl-params.conf } template { data = <<EOHclient_body_buffer_size 10k;client_header_buffer_size 1k;client_max_body_size 8m;large_client_header_buffers 2 1k;# Directive needs to be increased for certain site types to prevent ERROR 400# large_client_header_buffers 4 32k; EOH destination = local/nginx/buffers.conf } template { data = <<EOHadd_header Cache-Control public, must-revalidate, proxy-revalidate, max-age=0 ;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header X-NginX-Proxy true;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-Proto http;proxy_hide_header X-Frame-Options;proxy_set_header Accept-Encoding ;proxy_http_version 1.1;proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection upgrade ;proxy_set_header Host $host;proxy_cache_bypass $http_upgrade;proxy_max_temp_file_size 0;proxy_redirect off;proxy_read_timeout 240s; EOH destination = local/nginx/header.conf } template { data = <<EOHopen_file_cache max=1500 inactive=20s;open_file_cache_valid 30s;open_file_cache_min_uses 5;open_file_cache_errors off; EOH destination = local/nginx/cache.conf } template { data = <<EOHclient_header_timeout 3m;client_body_timeout 3m;keepalive_timeout 100;keepalive_requests 1000;send_timeout 3m; EOH destination = local/nginx/timeouts.conf } template { data = <<EOHgzip on;gzip_disable msie6 ;gzip_vary on;gzip_proxied any;gzip_comp_level 5;gzip_min_length 256;gzip_buffers 16 8k;gzip_http_version 1.1;gzip_types text/plain text/css application/json application/javascripttext/xml application/xml application/xml+rss text/javascriptimage/svg+xml application/xhtml+xml application/atom+xml; EOH destination = local/nginx/gzip.conf } } }}Tags:LINUXSecurityNGINXNomadConsulEdit this pagePreviousHashicorpNextSecure Timeserver - Deploying a NTS Server using Hashicorp NomadNGINX Ingress with NomadPreparationCertbotNomad Job File",
        "sublink1": "/docs/DevOps/Hashicorp/2022-09-24--nomad-nginx-ingress/2022-09-24",
        "chapter": "PLACEHOLDER",
        "tags": ["PLACEHOLDER"],
        "image": "PLACEHOLDER",
        "imagesquare": "PLACEHOLDER",
        "short": "Provision a containerized NGINX ingress using Hashicorp Nomad.",
        "abstract": "Provision a containerized NGINX ingress using Hashicorp Nomad."
    }{
        "title": "Build a NTP/S Timeserver Client in Go | Mike Polinowski",
        "series": ["PLACEHOLDER"],
        "type": "PLACEHOLDER",
        "description": "DevelopmentGoBuild a NTP/S Timeserver Client in GoOn this pageBuild a NTP Timeserver Client in GoBuild a NTP Timeserver Client in GoGo NTP ClientSending a RequestParse the ResponseRun the ClientGo NTS ClientBuild the ClientRunRunning as a Service with SystemDI have been looking into setting up a secure time server, connecting NTS clients and deploying the server using Hashicorp Nomad. Now I want to see if I can find a client written in Go that can easily be compiled for different operating systems.Go NTP Client​This code is based on the simple ntp client by Vladimir Vivien.The following lines shows the packet format for NTP v4. For the client we only use the first 48 bytes and ignoring the v4-specific extensions:0 1 2 30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|LI | VN |Mode | Stratum | Poll | Precision |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Root Delay |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Root Dispersion |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Reference ID |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| |+ Reference Timestamp (64) +| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| |+ Origin Timestamp (64) +| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| |+ Receive Timestamp (64) +| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| |+ Transmit Timestamp (64) +| |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+The structure below defines the NTP packet and its fields representing the format above:type packet struct { Settings uint8 // leap yr indicator, ver number, and mode Stratum uint8 // stratum of local clock Poll int8 // poll exponent Precision int8 // precision exponent RootDelay uint32 // root delay RootDispersion uint32 // root dispersion ReferenceID uint32 // reference id RefTimeSec uint32 // reference timestamp sec RefTimeFrac uint32 // reference timestamp fractional OrigTimeSec uint32 // origin time secs OrigTimeFrac uint32 // origin time fractional RxTimeSec uint32 // receive time secs RxTimeFrac uint32 // receive time frac TxTimeSec uint32 // transmit time secs TxTimeFrac uint32 // transmit time frac}Sending a Request​The NTP server provides its insecure - not NTS - service on Port 123 and expects communications using UDP. For this test - since I already NTS + key-secured my server - I will use a public NTP server to test the program:// Define ntp server addressvar host stringflag.StringVar(&host, e , 0.de.pool.ntp.org:123 , NTP host )flag.Parse()The following function opens a socket to communicate with the public NTP server over UDP and configure the connection’s read and write deadline to 15 seconds:// Open UDP connectionconn, err := net.Dial( udp , host)if err != nil { log.Fatalf( ERROR :: Connection failed with message: %v , err)}defer conn.Close()if err := conn.SetDeadline(time.Now().Add(15 * time.Second)); err != nil { log.Fatalf( ERROR :: Failed to set deadline: %v , err)}Before sending the request packet to the server, the first byte is used to specify configuration settings with a value of 0x1B (or 00011011 binary) which specifies client mode of 3, NTP version 3, leap year indicator of 0:// Specify the first byte of the request as// 00 011 011 (or 0x1B)// | | +-- client mode (3)// | + ----- version (3)// + -------- leap year indicator, 0 no warningreq := &packet{Settings: 0x1B}Next we use package binary to automatically encode the struct packet fields into its corresponding byte values and send them as big endian representation:// Send NTP time requestif err := binary.Write(conn, binary.BigEndian, req); err != nil { log.Fatalf( ERROR :: Sending request failed with message: %v , err)}Parse the Response​The response will be identical in format to the request and we can again use the binary package to decode the response bytes from the server into the packet struct value:// Receive NTP server responsersp := &packet{}if err := binary.Read(conn, binary.BigEndian, rsp); err != nil { log.Fatalf( ERROR :: Failed to read server response: %v , err)}On POSIX-compliant OS, time is expressed using the Unix time epoch (or secs since year 1970). NTP seconds are counted since 1900 and therefore must be corrected with an epoch offset to convert NTP seconds to Unix time by removing 70 yrs of seconds (1970-1900) or 2208988800 seconds:// NTP seconds to Unix time (1900 - 1970 in seconds)const ntpEpochOffset = 2208988800// Parse the time and print to consolesecs := float64(rsp.TxTimeSec) - ntpEpochOffsetnanos := (int64(rsp.TxTimeFrac) * 1e9) >> 32 // convert fractional to nanosfmt.Printf( %v\n , time.Unix(int64(secs), nanos))Run the Client​go run ./time.go2022-10-04 18:10:13.827640375 +0800 HKTgo build ./time.go./time -e time.kriss.re.kr:123 2022-10-04 18:14:59.364579986 +0800 HKTAnd to make sure that the error catching is actually working here an example that should fail using the NTS port:./time -e time.nist.gov:4460 2022/10/04 18:18:40 ERROR :: Failed to read server response: read udp 211.72.35.109:59692->132.163.96.6:4460: i/o timeoutA full NTP Client written in Go can be found here: beevik/ntp.Go NTS Client​A fully featured NTP and NTS client can be found here: ntsclient. This NTS client written in Go to can query for authenticated time using SNTP with NTS extension fields. It is build on the following libraries:ntske: NTS Key Exchange Go libraryntp: NTP/NTS Go libraryBuild the Client​git clone https://gitlab.com/hacklunch/ntsclient.gitcd ntsclientgo mod tidyThe repository contains a makefile we can use with the make command to build and install the client binary and configuration file. I will shorten the Makefile to the following to skip the installation part of it:PREFIX = /usr/localBINARY := ntsclientSRCS := client.go version.go go.mod go.sum$(BINARY): $(SRCS) go build -o $@lint:# see: .golangci.yml -golangci-lint run -golangci-lint run bump-version.gobump-major: go run bump-version.go version.go majorbump-minor: go run bump-version.go version.go minorbump-patch: go run bump-version.go version.go patchNow I can run the make command and end up with a binary ntsclient. To use the file I will have to create a configuration file ntsclient.toml:# Ask this server on this port about time# If :port is omitted, the default NTS-KE port 4460 will be used.# https://netnod.seserver= nts.ntp.se # Trust *only* this Certificate Authority certificate (PEM) to sign certficates# for server above.#cacert= cacert.crt # Interval in seconds between queriesinterval=1000Run​ntsclient does not output anything when querying and setting the time, unless something goes wrong (or debug output is turned on)../ntsclient --config ./ntsclient.tomlCould not set system time: operation not permittedsudo ./ntsclient --config ./ntsclient.tomlOk, now I got it running but of course I am not seeing anything anymore. So let's switch on the debug mode:sudo ./ntsclient --config ./ntsclient.toml --debugConf: &main.Config{Server: nts.ntp.se , CACert: , Interval:1000}Connecting to KE server nts.ntp.se:4460Using resolved KE server as NTP default: 194.58.207.77:123Record type 1Critical setRecord type 4Critical setRecord type 6Critical set(got negotiated NTP server: 194.58.207.80)Record type 7Critical set(got negotiated NTP port: 4123)Record type 5Record type 5Record type 5Record type 5Record type 5Record type 5Record type 5Record type 5Record type 0Critical setNTSKE exchange yielded: c2s: 7185b6d9658ae862f9f80027a4b4f56702fdcca16bd77064daf9fc12428cacb5 s2c: 3ca3feda3ce5cd55129bf21c51d576476284dbfe3910ca95e1966aff8fd79d49 server: 194.58.207.80 port: 4123 algo: 15 8 cookies: #1: 1d1f7bdc87a2c92ada1416006314cba9106a3b8a0957b404e8b3b9299cf0892eccb910fa8c071429a72e77c1a850ea018a17b1272101cbb45a32b90293788b1ec2aa5e013e3c5e15f5cdcb4bd1d30ac84780f8765b56fa419d085a36d66efe04adf4f67e #2: 1d1f7bdcb1a894e3fa5dfc00c63b3c9c14ed4761716900feeec48bcadc3591ea8addfe9dac46a630f5dedc513c741f977f5f7c3d62858b28158650323eea3c9a678627da31fff0e1ecc83fc0b8d632a87988ab60b690fe38ebb2e864bcddd3ad541dab00 #3: 1d1f7bdc5d1741b60c1b355843c82a48533032adb99f67577366c9fe6172b946dc11863db7d12b7e4d52368944ee88f2ebc25086fccbc446d6ffbe75546aac65f4a56ecfde4852f77247178a0f0063bdd228205bd30fe35c32d4ad1b4e8e9f8704c726e7 #4: 1d1f7bdc764e5dd5423656aaff1c69147a15cb9105484a1549183efefb27ce6890448f803ae4a558bfc93da2ee811362f67f7516e8dc01a4a56c28caccaedab2c861995b30b1b0000e125c2de251232b177af1f3ee2fe1b87e56c3d6ec8769c4ba1d3010 #5: 1d1f7bdc06c0d51832ceb31a23fc3dcacf352cd0f8532a43967089678c48eb4ffc6142e57c66af26c2c730a709a7ebb7b25742c07775e0747cb690ffa67271b478fb7773262f786db97ee1e34d02b9d9f8146fa91bd6945804d4cf00d3dcd3da30efcb03 #6: 1d1f7bdca7cde8901057519e738be42e6f35fd8cf6457069a79c474ce6c3ca00641cdc2a5b29daff557337b2654b0aa89c0999ff820e0a63bdae90c68164acbdac649263d6b193c2bb2bc974a7fa1b4f8e0bab4c7e7592e397945d996e741a9e7d58546d #7: 1d1f7bdc6ad2682416f848678e130931b67368209d929b92120e78c020ccda671ad7e33c3d826f5d33d67f9ae1f5de64ddd0498c2df4f5b45a186b91d8da2549c3e06ca35820b6227bbacfd5356fac996f11f44830f57d3788e23bcebdf3386f291fccd7 #8: 1d1f7bdc897ee754dcf978b180253e47c1a77055a1f149fbd61131187db0f03a3a45b35424d9a209902b254b212270fa325322ef2adb61de0f1fae5863e2312fa8fad64bedda1d4cc0deaa470eec485acf1bddf6e65788b407188b12a870a6cce274ef2aSending: Version: 4Mode: 3LeapIndicator: 3Stratum: 0Poll: 0Precision: 0RootDelay: 0sRootDispersion: 0sReferenceID: 0ReferenceTime: 0001-01-01 00:00:00 +0000 UTCOriginTime: 0001-01-01 00:00:00 +0000 UTCReceiveTime: 0001-01-01 00:00:00 +0000 UTCTransmitTime: 0001-01-01 00:00:00 +0000 UTCSpoofCookie: 2249980270020620447-- UniqueIdentifier EF ID: c4c7e91b9ca840a0b7e4e41c22bd143e2dfeb2768f9875e748a2a512613ac81c-- Cookie EF 1d1f7bdc87a2c92ada1416006314cba9106a3b8a0957b404e8b3b9299cf0892eccb910fa8c071429a72e77c1a850ea018a17b1272101cbb45a32b90293788b1ec2aa5e013e3c5e15f5cdcb4bd1d30ac84780f8765b56fa419d085a36d66efe04adf4f67e-- Authenticator EF NonceLen: 0 CipherTextLen: 0 Nonce: Ciphertext: Key: 7185b6d9658ae862f9f80027a4b4f56702fdcca16bd77064daf9fc12428cacb5wire: e300000000000000000000000000000025c17d04dad2965d25c17d04dad2965d25c17d04dad2965d1f3989227a37709f01040024c4c7e91b9ca840a0b7e4e41c22bd143e2dfeb2768f9875e748a2a512613ac81c020400681d1f7bdc87a2c92ada1416006314cba9106a3b8a0957b404e8b3b9299cf0892eccb910fa8c071429a72e77c1a850ea018a17b1272101cbb45a32b90293788b1ec2aa5e013e3c5e15f5cdcb4bd1d30ac84780f8765b56fa419d085a36d66efe04adf4f67e0404002800100010190d1ba7a999908f80b79652288ee53445c8bc790d21bc2c31454e823a659f9eReceived: Version: 4Mode: 4LeapIndicator: 0Stratum: 1Poll: 0Precision: -24RootDelay: 0sRootDispersion: 0sReferenceID: 1347441408ReferenceTime: 2022-10-04 11:39:51 +0000 UTCOriginTime: 0001-01-01 00:00:00 +0000 UTCReceiveTime: 2022-10-04 11:39:52.23693832 +0000 UTCTransmitTime: 2022-10-04 11:39:52.236942742 +0000 UTCSpoofCookie: 2249980270020620447-- UniqueIdentifier EF ID: c4c7e91b9ca840a0b7e4e41c22bd143e2dfeb2768f9875e748a2a512613ac81c-- Authenticator EF NonceLen: 16 CipherTextLen: 120 Nonce: 9d9ebcc66e8a825179b83334f20c1513 Ciphertext: 8d60b8bf3f5a4a15ec1ea0e9fa01e3abaa75c34c6735a69da940158970f1798bbc9836467d829469e4930a82fdbfd6898147192f4aad60e61d54d3b518ef1792df3cba2f610b876200cc94e7c5472c015a0fe94081327de006f3c607a0c19becc756044317db5fb94d3c60d9f408ef7c234d834de1429827 Key: Received wire: {36 1 0 -24 0 0 1347441408 16638155228222324736 2249980270020620447 16638155233534934369 16638155233534953361}response: &ntp.Response{Time:time.Date(2022, time.October, 4, 11, 39, 52, 236942742, time.UTC), ClockOffset:12618768, RTT:339863256, Precision:59, Stratum:0x1, ReferenceID:0x50505300, ReferenceTime:time.Date(2022, time.October, 4, 11, 39, 51, 0, time.UTC), RootDelay:0, RootDispersion:0, RootDistance:169931628, Leap:0x0, MinError:0, KissCode: , Poll:1000000000}Network time on 194.58.207.80:4123 2022-10-04 11:39:52.236942742 +0000 UTC. Local clock off by 12.618768ms.This seems to be working - I can verify it by manually setting my PC time. Starting the ntsclient will correct the mistake immediately. Nice!Running as a Service with SystemD​Installing ntsclient as a systemd service manually:cp ntsclient /usr/bin/cp ntsclient.toml /etc/cp contrib/ntsclient.service /etc/systemd/systemsystemctl enable ntsclientsystemctl start ntsclientTags:GoEdit this pagePreviousGo Build!NextWails - Build desktop apps using Go & ReactGo NTP ClientSending a RequestParse the ResponseRun the ClientGo NTS ClientBuild the ClientRunRunning as a Service with SystemD",
        "sublink1": "/docs/Development/Go/2022-10-04-go-ntp-client/2022-10-04",
        "chapter": "PLACEHOLDER",
        "tags": ["PLACEHOLDER"],
        "image": "PLACEHOLDER",
        "imagesquare": "PLACEHOLDER",
        "short": "A Go client that can interact with a key-secured Chrony NTS timeserver.",
        "abstract": "A Go client that can interact with a key-secured Chrony NTS timeserver."
    }